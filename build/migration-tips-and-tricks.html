---
layout: old-build
title: WinRT - API Design Notes
comments: true
---

<header>
    <h2>API Design and Windows Metadata Exporter</h2>
</header>

    <section>
        I spent today migrating an existing .NET library (Stacky - details <a href="http://stacky.codeplex.com/">here</a>) into a Windows Runtime-compatible API. While I started out with the goal of having one codebase to rule them all, I quickly found this was awfully idealistic and focused on just the WinRT stuff as an exercise. <br />
        <br />
        You can see the state of the code (warning: very rough) on <a href="https://bitbucket.org/shiftkey/stackywinrt">bitbucket</a>.
    </section>

    <section>
    <header>
        <h4>Caveats</h4>
    </header>
        All of this remarks below are subject to change. I have a few outstanding queries which I'll follow up with the product teams as I can find them on Twitter or on the forums.
    </section>

    <section>
        <header>
           <h4> What worked</h4>
        </header>

        Not much -  but I was unsurprised by that as there were many design decisions which were flagged at BUILD. I'll refer to some of the sessions I've watched from BUILD later.
    </section>

    <section>
        <header>
           <h4>How much has changed?</h4>
        </header>

        A fair bit - but again, is to be expected. The move to asychronous methods which can be invoked synchronously thanks to the syntactical sugar of <code>await</code> and <code>async</code> keywords demands this, but does have a lot of benefits.<br /><br />

        For people who have been doing .NET development, they should be familiar with the concept of a class library - a reusable set of classes which can be referenced in other projects.<br /><br />

        The Windows Runtime APIs behave slightly different (more on this later) and requires a different build process. Why do this? If you want your library to be consumed from C++ or a Javascript WinRT applications. Again, this is a topic far better covered by the product teams at BUILD, so go check them out.<br /><br />

        {% img center /img/posts/Win8/project-settings.png  %} <br /><br />

        When I change my project type to output a WinMD file, this changes the build process to include a tool called <strong>Windows Metadata Exporer</strong> (herein referred to as <strong>winmdexp</strong>). <br /><br />

        {% img center /img/posts/Win8/winmdexp-output.png %} <br /><br />

        You won't see this level of detail in your Output Window unless you switch the MSBuild output under <strong>Tools | Options | Projects and Solutions | Build and Run</strong> to Diagnostic or higher.<br /><br />

        You will see the errors and warnings though: <br /><br />
        
        {% img center /img/posts/Win8/error-output.png %} <br /><br />
        
    </section>

    <section>
        <header>
           <h4>Tips and Tricks</h4>
        </header>

        So after a couple of hours dancing with winmdexp, here's some notes on what it likes and what it doesn't.
    </section>
    <section>
        <header>
            <h5>Sealed. Use It.</h5>
        </header>

        When you create a simple class, like this: <br /><br />

        <pre>
public class MyClass
{
    public string MyProperty { get; set; }
}
        </pre>

        you'll see this error: <br /><br />

    <pre>Type 'MyProject.MyClass' is unsealed but is not enabled for composition. Either seal 'MyProject.MyClass', or mark it with the System.Runtime.InteropServices.WindowsRuntime.EnableCompositionAttribute so that you can derive from it. To use the class from JavaScript, you must seal it.</pre>

<br />

        At this point, you have two choices:

        <ul>
            <li>If you don't care about supporting Javascript applications consuming your API - for example, you require consumers to subclass this type, add the <code>[EnableComposition]</code> attribute to the class definition.</li>
            <li>If you want to support all languages, add the sealed keyword to your class so that no subclassing is possible.</li>
        </ul>

        And the easiest thing to do is to add the <code>sealed</code> keyword:<br /><br />

        <pre>
public <strong>sealed</strong> class MyClass
{
    public string MyProperty { get; set; }
}
        </pre>

        <strong>Notes:</strong> <br /><br />

        <ul>
            <li>As I worked my way through the codebase making the required changes, I was required to make conscious decisions around what I expose to consumers (the proxy and its APIs, the objects to return to the consumer), and what remains internal (helper functions, JSON parsing, etc) - the net result being a smaller footprint and more internal usage.</li>
            <li>The use of internal vs public for testability was a bit concerning - I hope the team have something in mind for doing an <code>[InternalsVisibleTo]</code>-esque testing option</li>
            <li>I need to try some edge-case scenarios around using the [EnableComposition] attribute - and how this impacts the consuming options</li>
        </ul>
    </section>
    <section>
        <header>
            <h5>Program to an interface, not an implementation</h5>
        </header>

        Let's change this class to something a little more complex: <br /><br />

        <pre>
public sealed class MyClass
{
    public List&lt;string&gt; MyProperty { get; set; }
}
        </pre>

        now we get multiple errors, such as: <br /><br />
    
    <pre>Method 'MyProject.MyClass.MyProperty.get()' has a parameter of type 'System.Collections.Generic.List&lt;System.String&gt;' in its signature.  Although this type is not a valid Windows Runtime type, it implements interfaces which are valid Windows Runtime types.  Consider changing the method signature to instead use one of the following types: 'System.Collections.Generic.IList&lt;System.String&gt;, System.Collections.Generic.IReadOnlyList&lt;System.String&gt;, System.Collections.Generic.IEnumerable&lt;System.String&gt;'.</pre>

    <br />

        Thankfully, the solution is right there in front of us.<br /><br />

        Rather than rewriting the entire BCL, the wizards in the WinRT team have supported <em>projecting</em> the .NET interface to the Windows Runtime interface (more info <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br230301%28v=VS.85%29.aspx#PassingAndReturningWinRT">here</a>). So we can just use one of the suggested interfaces and the runtime takes care of the rest.<br /><br />

        <pre>
public sealed class MyClass
{
    public IList&lt;string&gt; MyProperty { get; set; }
}
        </pre>

        <strong>Notes:</strong> <br /><br />

        <ul>
            <li>Common sense - good to see this being enforced as part of the API</li>
            <li>There are a number of read-only collections being added to the Windows Runtime (and .NET Framework 4.5). Hooray!</li>
        </ul>
    </section>

    <section>
        <header>
            <h5>Generic methods? Oh no you didn't!</h5>
        </header>

        First controversial topic! Let's say we're trying to parse arbitrary strings into JSON.<br /><br />

        <pre>
public static class MyStaticClass
{
    public static T Parse&lt;T&gt;(string text)
    {
        return default(T);
    }
}
        </pre>

        And we get scolded rather badly:<br /><br />

        
        <pre>'MyProject.MyStaticClass.Parse&lt;T&gt;(System.String)' is a generic method.  Windows Runtime methods may not be generic.<br />
Method 'MyProject.MyStaticClass.Parse&lt;T&gt;(System.String)' has a generic type parameter of type 'T' in its signature.  Generic type parameters may not appear in method signatures of Windows Runtime methods.<br />
Method 'MyProject.MyStaticClass.Parse&lt;T&gt;(System.String)' returns 'T', which is not a valid Windows Runtime type.  Methods exposed to Windows Runtime must only return Windows Runtime types.
        </pre>
        
        
        The Solution? Uh, don't do it.<br /><br />

        So, for all those MVVM frameworks who use helper methods like this:<br /><br />

<pre>
protected void NotifyOfPropertyChange&lt;TProperty&gt;(Expression&lt;Func&lt;TProperty&gt;&gt; property)
{
    NotifyOfPropertyChange(property.GetMemberInfo().Name);
}
</pre> <br />

        need to fall back to the simple method of passing strings. I've railed about how this is a <a href="/inotifypropertychanged-stop-the-madness.html">flawed concept</a> before, so now its a priority (for me at least) to integrate AOP-esque workflows into this process - so that we can do away with the boilerplate code (and reflection-fu). <br /><br />

        Or just mark the method as internal and don't expose it to the consumers - if the situation allows it.
    </section>

    <section>
        <header>
            <h5>Generic interfaces! Surely you can just...</h5>
        </header>

        Next scenario -  I wanted to extend an interface to add context around paging: <br /><br />

        <pre>
public interface IPager&lt;T&gt; : IEnumerable&lt;T&gt;
{
    int CurrentPage { get; }
    int PageSize { get; }
    int TotalItems { get; }
}
        </pre>

        No concrete classes. Still using a generic interface though...<br /><br />

    <pre>Interface 'MyProject.IPager&lt;T&gt;' requires interface 'System.Collections.Generic.IEnumerable&lt;T&gt;' which is not a Windows Runtime interface.  Exported interfaces may only require other Windows Runtime interfaces.
    Type 'MyProject.IPager&lt;T&gt;' is generic.  Windows Runtime types may not be generic.</pre>

    

        Damn. Another brick wall.<br /><br />

        <strong>Notes:</strong> <br /><br />

        <ul>
            <li>Why isn't this a supported scenario? Did I miss something?</li>
            <li>IIterable&lt;T&gt; is the complement of IEnumerable&lt;T&gt; - but it isn't part of the current build. Perhaps that is my issue...</li>
            <li>What generics are actually supported in WinRT? I haven't been able to find anything specific aside from a couple of slides in the afore-mentioned talks.</li>
        </ul>
    </section>

    <section>
        <header>
            <h5>What about virtual methods?</h5>
        </header>

        Can a consumer override a method when subclassing?<br /><br />

        <pre>
[EnableComposition]
public class SomeClass
{
    protected virtual void VirtualMethod(object param)
    {

    }
}
        </pre>

        Aaaand... no. <br /><br />

<pre>'MyProject.SomeClass.VirtualMethod(System.Object)' is a virtual method. Managed types may not expose new virtual methods in Windows Runtime.</pre>

        <strong>Notes:</strong> <br /><br />

        <ul>
            <li>Using <code>virtual</code> is usually (IMO) the last-choice when doing OO design in .NET. Meh. </li>
        </ul>
    </section>

    <section>
        <header>
            <h5>Fields! How do they work?</h5>
        </header>
        
        This gist describes it fairly well:<br /><br />

        <script src="https://gist.github.com/1256866.js"> </script>

    </section>

    <section>
        <header>
            <h5>Empty Class?</h5>
        </header>
        
        
        And if the tool finds an empty class:<br /><br />

        <pre>
public sealed class SomeClass
{
    
}
        </pre>

        It will ask you what on earth you were thinking!

        <br /><br />

<pre>Unable to determine a default interface for runtime class 'MyProject.MyClass'.  The class does not implement any interfaces, and no interface was generated for it because it does not contain any public methods, properties, or events.</pre>


    </section>

    <section>
        <header>
            <h5>Don't do async everywhere</h5>
        </header>
        
        
        You may be inclined to use async and await everywhere, seeing as they are the new black:<br /><br />

        <pre>
public async Task&lt;string&gt; Get(string url)
{
    var client = new HttpClient();
    var response = await client.GetAsync(url);
    return response.Content.ReadAsString();
}
        </pre>

        But Task&lt;T&gt; is a BCL type, not a WinRT type:

{% blockquote %}
'MyProject.MyClass.Get(System.String)' returns 'System.Threading.Tasks.Task&lt;System.String&gt;', which is not a valid Windows Runtime type.  Methods exposed to Windows Runtime must only return Windows Runtime types.
{% endblockquote %}

        The solution I've used - which I'm uncertain about, as I now have at worst 2x the methods defined (one private and at least one public method - excluding overloads) simply to support the ceremony of the WinRT bits - is from one of the talks:<br /><br />

        <pre>
public sealed class MyClass
{
    public IAsyncOperation&lt;string&gt; Get(string url)
    {
        return AsyncInfoFactory.Create(() => GetInternal(url));
    }

    private static async Task&lt;string&gt; GetInternal(string url)
    {
        var client = new HttpClient();
        var response = await client.GetAsync(url);
        return response.Content.ReadAsString();
    }
}
        </pre>

        The public method exposes an <code>IAsyncOperation</code> return type, which is created by the factory class. This is compatible with the WinRT APIs, while retaining all the features of the TPL Task API. <br /><br />

        <strong>Notes:</strong><br /><br />

        <ul>
            <li>This smells like another candidate for some post-build weaving - keep the source code clean and rewrite after to satisfy the WinRT APIs.</li>
            <li>Can we rename AsyncInfoFactory to something more specific - IAsyncInfo is the base interface for everything this creates, but I kept forgetting the class name whenever I had to add it. AsyncFactory? AsyncOperationFactory?</li>
        </ul>

    </section>

    <section>
        <header>
            <h5>What next?
        </header>

        <ul>
            <li>Watching <a href="http://social.msdn.microsoft.com/Forums/en-US/winappswithcsharp/thread/0191f069-4318-451f-9e24-72a505dadc8b/#0191f069-4318-451f-9e24-72a505dadc8b">this thread</a> for an answer about my interface subclassing question.</li>
            <li>Investigating if the use of <code>sealed</code> interferes with testability - and if there's a good workaround.</li>
            <li>Finish the damn library migration</li>
        </ul>

        If you've got any feedback on this (or perhaps I've gone astray on something), you can reach me on <a href="http://twitter.com/shiftkey">Twitter (@shiftkey)</a> or you can email me - 'me' @ this-domain. <br /><br />



    </section>